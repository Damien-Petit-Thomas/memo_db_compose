--
-- PostgreSQL database dump
--

-- Dumped from database version 16.1 (Ubuntu 16.1-1.pgdg22.04+1)
-- Dumped by pg_dump version 16.1 (Ubuntu 16.1-1.pgdg22.04+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;
-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.category
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    slug character varying(100) COLLATE pg_catalog."default" NOT NULL,
    color character varying(7) COLLATE pg_catalog."default" NOT NULL DEFAULT '#000000'::character varying,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    CONSTRAINT category_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.content_type
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    type character varying(50) COLLATE pg_catalog."default" DEFAULT NULL::character varying,
    available_style integer[],
    CONSTRAINT content_type_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.lexicon
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    word character varying(100) COLLATE pg_catalog."default" NOT NULL,
    definition text COLLATE pg_catalog."default" NOT NULL,
    category_id integer,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    CONSTRAINT lexicon_pkey PRIMARY KEY (id),
    CONSTRAINT word_must_be_unique UNIQUE (word)
);

CREATE TABLE IF NOT EXISTS public.link
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    url character varying(100) COLLATE pg_catalog."default" NOT NULL,
    "group" character varying(100) COLLATE pg_catalog."default" NOT NULL DEFAULT 'divers'::character varying,
    category_id integer NOT NULL,
    memo_id integer NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    CONSTRAINT link_pkey PRIMARY KEY (id),
    CONSTRAINT link_url_key UNIQUE (url)
);

CREATE TABLE IF NOT EXISTS public.memo
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    title character varying(100) COLLATE pg_catalog."default" NOT NULL,
    category_id integer,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    slug character varying COLLATE pg_catalog."default",
    CONSTRAINT memo_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.memo_content
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    type_id integer NOT NULL,
    memo_id integer NOT NULL,
    content text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    "position" integer,
    style_id integer DEFAULT 3,
    CONSTRAINT memo_content_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.memo_tag
(
    memo_id integer NOT NULL,
    tag_id integer NOT NULL,
    CONSTRAINT memo_tag_pkey PRIMARY KEY (memo_id, tag_id)
);

CREATE TABLE IF NOT EXISTS public.result
(
    jsonb_agg jsonb
);

CREATE TABLE IF NOT EXISTS public.style
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    css text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT style_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.tag
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    slug character varying(100) COLLATE pg_catalog."default" NOT NULL,
    color character varying(7) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    CONSTRAINT tag_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.todo
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    description text COLLATE pg_catalog."default" NOT NULL,
    done boolean NOT NULL DEFAULT false,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    CONSTRAINT todo_pkey PRIMARY KEY (id)
);



CREATE TABLE IF NOT EXISTS public."user"
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    email text  COLLATE pg_catalog."default" NOT NULL  UNIQUE CHECK("email" ~ '^[a-z0-9!#$%&''*+/=?^_‘{|}~-]+(?:\.[a-z0-9!#$%&''*+/=?^_‘{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$'),
    password text COLLATE pg_catalog."default" NOT NULL,
    name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone,
    CONSTRAINT user_pkey PRIMARY KEY (id),
);


ALTER TABLE IF EXISTS public.lexicon
    ADD CONSTRAINT lexicon_category_id_fkey FOREIGN KEY (category_id)
    REFERENCES public.category (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.link
    ADD CONSTRAINT link_category_id_fkey FOREIGN KEY (category_id)
    REFERENCES public.category (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.link
    ADD CONSTRAINT link_memo_id_fkey FOREIGN KEY (memo_id)
    REFERENCES public.memo (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.memo
    ADD CONSTRAINT fk_memo_category FOREIGN KEY (category_id)
    REFERENCES public.category (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.memo
    ADD CONSTRAINT memo_category_id_fkey FOREIGN KEY (category_id)
    REFERENCES public.category (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.memo_content
    ADD CONSTRAINT memo_content_memo_id_fkey FOREIGN KEY (memo_id)
    REFERENCES public.memo (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.memo_content
    ADD CONSTRAINT memo_content_type_id_fkey FOREIGN KEY (type_id)
    REFERENCES public.content_type (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.memo_tag
    ADD CONSTRAINT memo_tag_memo_id_fkey FOREIGN KEY (memo_id)
    REFERENCES public.memo (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.memo_tag
    ADD CONSTRAINT memo_tag_tag_id_fkey FOREIGN KEY (tag_id)
    REFERENCES public.tag (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS sqitch.changes
    ADD CONSTRAINT changes_project_fkey FOREIGN KEY (project)
    REFERENCES sqitch.projects (project) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS sqitch.dependencies
    ADD CONSTRAINT dependencies_change_id_fkey FOREIGN KEY (change_id)
    REFERENCES sqitch.changes (change_id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS sqitch.dependencies
    ADD CONSTRAINT dependencies_dependency_id_fkey FOREIGN KEY (dependency_id)
    REFERENCES sqitch.changes (change_id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS sqitch.events
    ADD CONSTRAINT events_project_fkey FOREIGN KEY (project)
    REFERENCES sqitch.projects (project) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS sqitch.tags
    ADD CONSTRAINT tags_change_id_fkey FOREIGN KEY (change_id)
    REFERENCES sqitch.changes (change_id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS sqitch.tags
    ADD CONSTRAINT tags_project_fkey FOREIGN KEY (project)
    REFERENCES sqitch.projects (project) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE NO ACTION;

END;
--
-- Data for Name: category; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.category (id, name, slug, color, created_at, updated_at) FROM stdin;
73	Docker	docker	#26a269	2024-01-05 13:09:31.305139+01	\N
67	Github Action	github-action	#413779	2023-12-13 03:37:24.684047+01	\N
\.


--
-- Data for Name: content_type; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.content_type (id, name, created_at, updated_at, type, available_style) FROM stdin;
2	paragraphe	2023-11-28 13:42:04.720384+01	2023-11-29 13:35:59.136335+01	\N	\N
4	blockquote	2023-11-29 13:31:52.929831+01	2023-12-10 21:49:27.226328+01	\N	\N
5	code	2023-12-15 01:22:59.879496+01	\N	\N	\N
6	detail	2023-12-15 15:59:07.606761+01	\N	\N	\N
7	summary	2023-12-16 15:08:13.142715+01	\N	\N	\N
10	noteCard	2023-12-17 23:12:25.576574+01	2023-12-17 23:52:00.542548+01	\N	{1,2}
\.


--
-- Data for Name: lexicon; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.lexicon (id, word, definition, category_id, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: link; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.link (id, name, url, "group", category_id, memo_id, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: memo; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.memo (id, title, category_id, created_at, updated_at, slug) FROM stdin;
\.


--
-- Data for Name: memo_content; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.memo_content (id, type_id, memo_id, content, created_at, updated_at, "position", style_id) FROM stdin;
\.


--
-- Data for Name: memo_tag; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.memo_tag (memo_id, tag_id) FROM stdin;
\.


--
-- Data for Name: result; Type: TABLE DATA; Schema: public; Owner: -
--




--
-- Data for Name: style; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.style (id, name, created_at, updated_at, css) FROM stdin;
3	default	2023-12-17 23:41:48.668563+01	\N	
1	note	2023-12-17 18:49:03.90638+01	2023-12-18 02:08:08.715895+01	background-color: #09273; border-left: 4px solid #5E9EF;
2	warning	2023-12-17 18:51:01.472365+01	2023-12-18 02:11:28.21124+01	background-color: #712828; border-left: 4px solid #935656;
\.


--
-- Data for Name: tag; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.tag (id, name, slug, color, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: todo; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public.todo (id, description, done, created_at, updated_at) FROM stdin;
72	css	t	2023-12-21 23:09:57.834329+01	2023-12-21 23:11:00.677687+01
\.


--
-- Data for Name: user; Type: TABLE DATA; Schema: public; Owner: -
--

COPY public."user" (id, name, email, password, created_at, updated_at) FROM stdin;
\.


--
-- Name: category_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.category_id_seq', 73, true);


--
-- Name: content_type_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.content_type_id_seq', 10, true);


--
-- Name: lexicon_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.lexicon_id_seq', 13, true);


--
-- Name: link_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.link_id_seq', 2036, true);


--
-- Name: memo_content_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.memo_content_id_seq', 1090, true);


--
-- Name: memo_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.memo_id_seq', 226, true);


--
-- Name: style_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.style_id_seq', 3, true);


--
-- Name: tag_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.tag_id_seq', 64, true);


--
-- Name: todo_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.todo_id_seq', 72, true);


--
-- Name: user_id_seq; Type: SEQUENCE SET; Schema: public; Owner: -
--

SELECT pg_catalog.setval('public.user_id_seq', 1, false);


--
-- PostgreSQL database dump complete
--

-- FUNCTION: public.get_style_by_content_type_id(integer)

-- DROP FUNCTION IF EXISTS public.get_style_by_content_type_id(integer);

CREATE OR REPLACE FUNCTION public.get_style_by_content_type_id(
	content_type_id integer)
    RETURNS jsonb
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
  result jsonb;
BEGIN
  SELECT
    jsonb_agg(
      jsonb_build_object(
        'id', s.id,
        'name', s.name,
        'css', s.css,
        'created_at', s.created_at,
        'updated_at', s.updated_at
      )
    )
  INTO result
  FROM style s
  JOIN content_type ct ON s.id = ANY(ct.style_id)
  WHERE ct.id = content_type_id;

  RETURN result;
END;
$BODY$;

ALTER FUNCTION public.get_style_by_content_type_id(integer)
    OWNER TO memo;
-- FUNCTION: public.getalllinks()

-- DROP FUNCTION IF EXISTS public.getalllinks();

CREATE OR REPLACE FUNCTION public.getalllinks(
	)
    RETURNS TABLE(id integer, name character varying, url character varying, "group" character varying, category_slug character varying, category_name character varying, category_id integer, memo_slug character varying, memo_title character varying, memo_id integer, created_at timestamp with time zone, updated_at timestamp with time zone) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
  RETURN QUERY (
    SELECT
      l.id,
      l.name,
      l.url,
      l."group",
      c.slug AS category_slug,
      c.name AS category_name,
      l.category_id,
      m.slug AS memo_slug,
      m.title AS memo_title,
      l.memo_id,
      l.created_at,
      l.updated_at
    FROM link l
    JOIN category c ON l.category_id = c.id
    JOIN memo m ON l.memo_id = m.id
    ORDER BY l.name
  );
END;
$BODY$;

ALTER FUNCTION public.getalllinks()
    OWNER TO memo;
-- FUNCTION: public.getallmemos()

-- DROP FUNCTION IF EXISTS public.getallmemos();

CREATE OR REPLACE FUNCTION public.getallmemos(
	)
    RETURNS jsonb
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
  result jsonb;
BEGIN
  SELECT
    jsonb_agg(
      jsonb_build_object(
        'id', m.id,
        'title', m.title,
        'slug', m.slug,
        'category', jsonb_build_object(
          'id', m.category_id,
          'name', c.name,
          'slug', c.slug,
          'color', c.color,
          'created_at', c.created_at,
          'updated_at', c.updated_at
        ),
        'created_at', m.created_at,
        'updated_at', m.updated_at,
        'tags', (
          SELECT
            jsonb_agg(
              jsonb_build_object(
                'id', t.id,
                'name', t.name,
                'slug', t.slug,
                'color', t.color,
                'created_at', t.created_at,
                'updated_at', t.updated_at
              )
            )
          FROM memo_tag mt
          JOIN tag t ON mt.tag_id = t.id
          WHERE mt.memo_id = m.id
        ),
        'contents', (
          SELECT
            jsonb_agg(
              jsonb_build_object(
                'id', mc.id,
                'type', jsonb_build_object(
                  'id', ct.id,
                  'name', ct.name,
                  'created_at', ct.created_at,
                  'updated_at', ct.updated_at
                ),
                'style', jsonb_build_object(
                  'id', s.id,
                  'name', s.name,
                  'css', s.css,
                  'created_at', s.created_at,
                  'updated_at', s.updated_at
                ),
                'position', mc.position,
                'content', mc.content,
                'created_at', mc.created_at,
                'updated_at', mc.updated_at
              )
            )
          FROM memo_content mc
          JOIN content_type ct ON mc.type_id = ct.id
          JOIN style s ON mc.style_id = s.id
          WHERE mc.memo_id = m.id
        )
      )
    )
  INTO result
  FROM memo m
  LEFT JOIN category c ON m.category_id = c.id;

  RETURN result;
END;
$BODY$;

ALTER FUNCTION public.getallmemos()
    OWNER TO memo;
-- FUNCTION: public.getmemo(integer)

-- DROP FUNCTION IF EXISTS public.getmemo(integer);

CREATE OR REPLACE FUNCTION public.getmemo(
	memo_id integer)
    RETURNS jsonb
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
  result jsonb;
BEGIN
  

  SELECT
    jsonb_build_object(
      'id', m.id,
      'title', m.title,
      'slug', m.slug,
      'category', jsonb_build_object(
        'id', c.id,
        'name', c.name,
        'slug', c.slug,
        'color', c.color,
        'created_at', c.created_at,
        'updated_at', c.updated_at
      ),
      'created_at', m.created_at,
      'updated_at', m.updated_at,
      'tags', (
        SELECT jsonb_agg(
          jsonb_build_object(
            'id', t.id,
            'name', t.name,
            'slug', t.slug,
            'color', t.color,
            'created_at', t.created_at,
            'updated_at', t.updated_at
          )
        )
        FROM memo_tag mt
        JOIN tag t ON mt.tag_id = t.id
        WHERE mt.memo_id = m.id
      ),
      'contents', (
        SELECT jsonb_agg(
          jsonb_build_object(
            'id', mc.id,
            'type', jsonb_build_object(
              'id', ct.id,
              'name', ct.name,
              'css', ct.css,
              'created_at', ct.created_at,
              'updated_at', ct.updated_at
            ),
              'position', mc.position,
            'content', mc.content,
            'created_at', mc.created_at,
            'updated_at', mc.updated_at
          )ORDER BY mc.position
        )
        FROM memo_content mc
        JOIN content_type ct ON mc.type_id = ct.id
        WHERE mc.memo_id = m.id
     
      )
    )
  INTO result
  FROM
    memo AS m
    LEFT JOIN category AS c ON m.category_id = c.id
    
  WHERE
    m.id = memo_id;

  RETURN result;
END;
$BODY$;

ALTER FUNCTION public.getmemo(integer)
    OWNER TO memo;
-- FUNCTION: public.getmemobyslug(text)

-- DROP FUNCTION IF EXISTS public.getmemobyslug(text);

CREATE OR REPLACE FUNCTION public.getmemobyslug(
	p_slug text)
    RETURNS jsonb
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
  result jsonb;
BEGIN
  SELECT
    jsonb_agg(
      jsonb_build_object(
        'id', m.id,
        'title', m.title,
        'slug', m.slug,
        'category', jsonb_build_object(
          'id', c.id,
          'name', c.name,
          'slug', c.slug,
          'color', c.color,
          'created_at', c.created_at,
          'updated_at', c.updated_at
        ),
        'created_at', m.created_at,
        'updated_at', m.updated_at,
        'tags', (
          SELECT jsonb_agg(
            jsonb_build_object(
              'id', t.id,
              'name', t.name,
              'slug', t.slug,
              'color', t.color,
              'created_at', t.created_at,
              'updated_at', t.updated_at
            )
          )
          FROM memo_tag mt
          JOIN tag t ON mt.tag_id = t.id
          WHERE mt.memo_id = m.id
        ),
        'contents', (
          SELECT jsonb_agg(
            jsonb_build_object(
              'id', mc.id,
              'type', jsonb_build_object(
                'id', ct.id,
                'name', ct.name,
                'css', ct.css,
                'created_at', ct.created_at,
                'updated_at', ct.updated_at
              ),
              'content', mc.content,
              'created_at', mc.created_at,
              'updated_at', mc.updated_at
            )
          )
          FROM memo_content mc
          JOIN content_type ct ON mc.type_id = ct.id
          WHERE mc.memo_id = m.id
        )
      )
    )
  INTO result
  FROM
    memo AS m
    LEFT JOIN category AS c ON m.category_id = c.id
  WHERE m.slug = p_slug;

  RETURN result;
END;
$BODY$;

ALTER FUNCTION public.getmemobyslug(text)
    OWNER TO memo;
